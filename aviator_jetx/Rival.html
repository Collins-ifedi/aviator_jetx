<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Aviator X â€” Premium Crash</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <style>
        :root {
            --bg-dark: #0b0e14;
            --bg-panel: #131722;
            --accent-red: #ff3b3b;
            --accent-green: #27ff9a;
            --accent-blue: #3b82f6;
            --text-main: #ffffff;
            --text-muted: #8492a6;
            --border: rgba(255, 255, 255, 0.08);
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        body {
            margin: 0;
            background-color: var(--bg-dark);
            font-family: var(--font-family);
            color: var(--text-main);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* === HEADER === */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            z-index: 10;
        }

        .brand {
            font-weight: 800;
            font-size: 18px;
            letter-spacing: -0.5px;
        }
        .brand span { color: var(--accent-red); }

        .balance-pill {
            background: rgba(255,255,255,0.05);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .balance-pill strong { color: var(--accent-green); }

        /* === HISTORY BAR === */
        .history-bar {
            height: 36px;
            background: var(--bg-dark);
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 8px;
            overflow-x: auto;
            border-bottom: 1px solid var(--border);
            scrollbar-width: none; /* Hide scrollbar Firefox */
        }
        .history-bar::-webkit-scrollbar { display: none; } /* Hide scrollbar Chrome */

        .history-pill {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            background: rgba(255,255,255,0.06);
            color: var(--text-muted);
            white-space: nowrap;
        }
        .history-pill.high { color: var(--accent-green); background: rgba(39, 255, 154, 0.1); }
        .history-pill.crash { color: var(--accent-red); background: rgba(255, 59, 59, 0.1); }

        /* === GAME STAGE === */
        .stage {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1a1f2e 0%, #0b0e14 100%);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
        }

        .big-multiplier {
            font-size: 56px;
            font-weight: 900;
            text-shadow: 0 0 30px rgba(0,0,0,0.5);
            font-variant-numeric: tabular-nums;
            transition: color 0.2s;
        }
        
        .status-text {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-top: 8px;
            opacity: 0.8;
        }

        .crashed .big-multiplier { color: var(--accent-red); animation: shake 0.4s ease-in-out; }
        .flying .big-multiplier { color: #fff; }
        .loading .big-multiplier { color: var(--text-muted); font-size: 24px; }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        /* === CONTROLS === */
        .controls {
            background: var(--bg-panel);
            padding: 16px;
            border-top: 1px solid var(--border);
            padding-bottom: max(16px, env(safe-area-inset-bottom));
        }

        .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }

        .input-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        label {
            font-size: 11px;
            color: var(--text-muted);
            font-weight: 600;
            text-transform: uppercase;
        }

        .input-wrapper {
            position: relative;
        }

        input {
            width: 100%;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            outline: none;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }
        
        input:focus { border-color: var(--accent-blue); }

        .btn-main {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 800;
            text-transform: uppercase;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .btn-main:active { transform: scale(0.98); }

        .btn-bet {
            background: var(--accent-green);
            color: #052e18;
            box-shadow: 0 4px 20px rgba(39, 255, 154, 0.3);
        }

        .btn-cashout {
            background: var(--accent-red); /* Changed to Red/Orange for cashout urgency */
            background: linear-gradient(135deg, #ff9f43, #ff6b6b);
            color: white;
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.4);
        }
        
        .btn-disabled {
            background: #2a303e;
            color: #556075;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* === TOAST === */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: rgba(39, 255, 154, 0.95);
            color: #000;
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: 700;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: transform 0.3s ease;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .toast.visible { transform: translateX(-50%) translateY(0); }
        
    </style>
</head>
<body>

<header>
    <div class="brand">AVIATOR <span>X</span></div>
    <div class="balance-pill">
        <span>Credits:</span>
        <strong id="balanceEl">0.00</strong>
    </div>
</header>

<div class="history-bar" id="historyBar">
    </div>

<div class="stage" id="stage">
    <canvas id="gameCanvas"></canvas>
    
    <div class="overlay" id="overlay">
        <div class="status-text" id="statusText">CONNECTING...</div>
        <div class="big-multiplier" id="multiplierDisplay">1.00x</div>
    </div>
</div>

<div class="controls">
    <div class="input-row">
        <div class="input-group">
            <label>Bet Amount</label>
            <div class="input-wrapper">
                <input type="number" id="betInput" value="10" min="1" step="1">
            </div>
        </div>
        <div class="input-group">
            <label>Auto Cashout (x)</label>
            <div class="input-wrapper">
                <input type="number" id="autoInput" placeholder="None" min="1.1" step="0.1">
            </div>
        </div>
    </div>
    
    <button id="mainBtn" class="btn-main btn-bet">PLACE BET</button>
</div>

<div class="toast" id="toast">
    <span>ðŸ’°</span> <span id="toastMsg">You won 100.00!</span>
</div>

<script>
    // ============================================
    // CONSTANTS & CONFIG
    // ============================================
    const CONFIG = {
        POLL_INTERVAL: 100, // ms
        GRAPH_COLOR: '#ff3b3b',
        GRID_COLOR: 'rgba(255,255,255,0.05)',
        AXIS_COLOR: 'rgba(255,255,255,0.2)'
    };

    // ============================================
    // STATE MANAGEMENT
    // ============================================
    const state = {
        userId: localStorage.getItem("u_id") || "guest_" + Math.random().toString(36).substr(2, 9),
        balance: 0.00,
        gameState: "OFFLINE", // IDLE, BETTING, FLYING, CRASHED
        currentMultiplier: 1.00,
        myBet: null, // { amount, auto, active: bool }
        history: [],
        serverState: {}
    };

    localStorage.setItem("u_id", state.userId);
    const tg = window.Telegram?.WebApp;
    if(tg) {
        tg.expand();
        tg.ready();
    }

    // ============================================
    // API LAYER
    // ============================================
    async function api(endpoint, body) {
        try {
            const opts = {
                method: body ? 'POST' : 'GET',
                headers: { 'Content-Type': 'application/json' }
            };
            if(body) {
                body.user_id = state.userId;
                opts.body = JSON.stringify(body);
            }
            const res = await fetch(endpoint, opts);
            const data = await res.json();
            if(!res.ok) throw new Error(data.detail || "API Error");
            return data;
        } catch(e) {
            console.error(e);
            return null;
        }
    }

    // ============================================
    // UI UPDATERS
    // ============================================
    const els = {
        balance: document.getElementById('balanceEl'),
        multiplier: document.getElementById('multiplierDisplay'),
        status: document.getElementById('statusText'),
        btn: document.getElementById('mainBtn'),
        betIn: document.getElementById('betInput'),
        autoIn: document.getElementById('autoInput'),
        overlay: document.getElementById('overlay'),
        history: document.getElementById('historyBar'),
        toast: document.getElementById('toast'),
        toastMsg: document.getElementById('toastMsg')
    };

    function updateBalance(val) {
        state.balance = val;
        els.balance.textContent = val.toFixed(2);
    }

    function showToast(msg) {
        els.toastMsg.textContent = msg;
        els.toast.classList.add('visible');
        setTimeout(() => els.toast.classList.remove('visible'), 3000);
    }

    function addHistory(mult) {
        state.history.unshift(mult);
        if(state.history.length > 20) state.history.pop();
        
        const div = document.createElement('div');
        div.className = `history-pill ${mult >= 2.0 ? 'high' : 'crash'}`;
        div.textContent = mult.toFixed(2) + 'x';
        
        els.history.prepend(div);
        if(els.history.children.length > 20) els.history.lastChild.remove();
    }

    // ============================================
    // CANVAS ENGINE
    // ============================================
    class GraphEngine {
        constructor() {
            this.cvs = document.getElementById('gameCanvas');
            this.ctx = this.cvs.getContext('2d');
            this.width = 0;
            this.height = 0;
            this.animId = null;
            this.points = []; // {x, y} normalized
            
            window.addEventListener('resize', () => this.resize());
            this.resize();
        }

        resize() {
            this.width = this.cvs.parentElement.clientWidth;
            this.height = this.cvs.parentElement.clientHeight;
            this.cvs.width = this.width * window.devicePixelRatio;
            this.cvs.height = this.height * window.devicePixelRatio;
            this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        reset() {
            this.points = [{x:0, y:0}];
        }

        update(mult, isFlying) {
            if(!isFlying) return;
            
            // Map multiplier to curve (Time vs Value)
            // Visual mapping: X grows linearly with time, Y grows exponentially
            // We approximate this by storing points.
            
            // Simple visualizer: X moves 0->1, Y moves 0->1 based on multiplier
            // For a crash game, visual curve is usually y = x^2 approx.
            
            // Push point:
            const elapsed = Date.now() / 1000;
            // This is purely visual:
            this.points.push({t: Date.now(), m: mult});
        }

        draw(gameState) {
            const ctx = this.ctx;
            const w = this.width;
            const h = this.height;

            ctx.clearRect(0, 0, w, h);

            // Draw Grid
            this.drawGrid(w, h);

            if(gameState === 'IDLE') return;

            // Draw Curve
            ctx.beginPath();
            ctx.moveTo(0, h);

            // Logic: As multiplier grows, the scale changes.
            // We want the tip to always be somewhat top-right unless very early.
            
            let scaleY = 100; // Pixels per 1x
            if (state.currentMultiplier > 2) scaleY = h / state.currentMultiplier * 0.8;
            
            // Bezier curve approximation for smooth flight
            const progress = Math.min(1, (state.currentMultiplier - 1) / 10); // 0 to 1
            
            const startX = 0;
            const startY = h;
            const endX = w * 0.8; 
            const endY = h - (Math.log(state.currentMultiplier) * 50); // Logarithmic visual height
            
            // Actual draw logic (Simplified for robustness)
            // We draw a quadratic curve from bottom-left to calculated tip
            const tipX = (state.currentMultiplier === 1) ? 20 : w * 0.6;
            const tipY = (state.currentMultiplier === 1) ? h - 20 : h - (Math.min(h * 0.8, (state.currentMultiplier - 1) * 100));
            
            // Better visual:
            // X is time. Y is multiplier.
            // If we just started, tip is bottom left.
            // If we are high, tip is top right.
            
            // Dynamic Coordinate System
            // X-axis: 0 to 10 seconds (scrolls after)
            // Y-axis: 1x to 2x (scales after)

            ctx.lineWidth = 4;
            ctx.strokeStyle = (gameState === 'CRASHED') ? '#ff3b3b' : '#27ff9a';
            
            // Draw a smooth curve ending at tip
            ctx.beginPath();
            ctx.moveTo(0, h);
            ctx.quadraticCurveTo(tipX * 0.5, h, tipX, tipY);
            ctx.stroke();

            // Gradient Fill
            const grad = ctx.createLinearGradient(0, tipY, 0, h);
            grad.addColorStop(0, (gameState === 'CRASHED') ? 'rgba(255,59,59,0.2)' : 'rgba(39,255,154,0.2)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fill();

            // Draw Plane/Rocket
            if(gameState === 'FLYING') {
                ctx.save();
                ctx.translate(tipX, tipY);
                // Simple Rocket Icon (Emoji is easiest for canvas without loading sprites)
                ctx.font = "24px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("ðŸš€", 0, 0);
                ctx.restore();
            } else if (gameState === 'CRASHED') {
                ctx.save();
                ctx.translate(tipX, tipY);
                ctx.font = "24px Arial";
                ctx.fillText("ðŸ’¥", 0, 0);
                ctx.restore();
            }
        }

        drawGrid(w, h) {
            const ctx = this.ctx;
            ctx.strokeStyle = CONFIG.GRID_COLOR;
            ctx.lineWidth = 1;

            // Offset for animation
            const time = Date.now() / 50;
            const offsetX = -(time % 50);
            const offsetY = (time % 50);

            ctx.beginPath();
            // Vertical lines
            for(let x = offsetX; x < w; x += 50) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
            }
            // Horizontal lines
            for(let y = offsetY; y < h; y += 50) {
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
            }
            ctx.stroke();
        }
    }

    const graph = new GraphEngine();

    // ============================================
    // CONTROLLER
    // ============================================
    async function init() {
        // 1. Get Balance
        const r = await api('/api/init', { user_id: state.userId });
        if(r) updateBalance(r.balance);

        // 2. Start Loops
        setInterval(poll, CONFIG.POLL_INTERVAL);
        loop(); // Canvas Loop
    }

    async function poll() {
        const r = await api('/api/state');
        if(!r) return;

        const prevStatus = state.gameState;
        state.gameState = r.status;
        state.serverState = r;

        // Sync Multiplier
        if(r.status === 'FLYING') {
            state.currentMultiplier = r.multiplier;
            els.multiplier.textContent = r.multiplier.toFixed(2) + 'x';
        } else if (r.status === 'CRASHED') {
            // Ensure we show the final crash point
            state.currentMultiplier = r.crash_point || r.multiplier;
            els.multiplier.textContent = state.currentMultiplier.toFixed(2) + 'x';
        }

        // State Transitions
        if(prevStatus !== r.status) {
            handleStateChange(prevStatus, r.status);
        }
        
        // Auto-update bet button state based on round
        updateControls();
    }

    function handleStateChange(oldS, newS) {
        els.overlay.classList.remove('crashed', 'flying', 'loading');
        
        if(newS === 'BETTING') {
            els.status.textContent = "PLACE YOUR BETS";
            els.overlay.classList.add('loading');
            state.currentMultiplier = 1.00;
            els.multiplier.textContent = "1.00x";
            graph.reset();
            
            // Clean up old bet if round restart
            if(state.myBet && !state.myBet.active) state.myBet = null;
        }
        else if(newS === 'FLYING') {
            els.status.textContent = "CURRENT PAYOUT";
            els.overlay.classList.add('flying');
            
            // If we have a pending bet, mark it active
            if(state.myBet && state.myBet.status === 'pending') {
                state.myBet.active = true;
                state.myBet.status = 'active';
            }
        }
        else if(newS === 'CRASHED') {
            els.status.textContent = "FLEW AWAY";
            els.overlay.classList.add('crashed');
            addHistory(state.currentMultiplier);
            
            if(state.myBet && state.myBet.active) {
                // Lost
                state.myBet = null;
            }
        }
    }

    function updateControls() {
        const btn = els.btn;
        const s = state.gameState;

        // Logic for Button
        // Case 1: My bet is active (I am in the game) -> Show Cashout
        if(state.myBet && state.myBet.active) {
            btn.textContent = `CASHOUT ${(state.myBet.amount * state.currentMultiplier).toFixed(0)}`;
            btn.className = "btn-main btn-cashout";
            btn.onclick = doCashout;
            return;
        }

        // Case 2: Round is Flying, I am not in -> Wait
        if(s === 'FLYING') {
            btn.textContent = "WAIT FOR NEXT ROUND";
            btn.className = "btn-main btn-disabled";
            btn.onclick = null;
            return;
        }

        // Case 3: Betting/Idle/Crashed -> Place Bet
        btn.textContent = "PLACE BET";
        btn.className = "btn-main btn-bet";
        btn.onclick = placeBet;
    }

    // ============================================
    // ACTIONS
    // ============================================
    async function placeBet() {
        const amount = parseFloat(els.betIn.value);
        const auto = parseFloat(els.autoIn.value) || null;
        
        if(!amount || amount <= 0) return alert("Invalid amount");

        // UI Optimistic Update
        els.btn.textContent = "BETTING...";
        els.btn.classList.add('btn-disabled');

        // Note: For this demo logic, if IDLE, we start round. 
        // In prod, start-round is auto. We simulate it here if needed.
        if(state.gameState === 'IDLE' || state.gameState === 'CRASHED') {
             // In this specific demo env, we trigger start round if it's dead
             await api('/api/start-round', { client_seed: Date.now().toString() });
        }

        const res = await api('/api/place-bet', { amount, auto_cashout: auto });
        
        if(res && res.status === 'accepted') {
            state.myBet = {
                amount: amount,
                auto: auto,
                active: false, // Wait for FLYING
                status: 'pending'
            };
            updateBalance(res.new_balance);
        } else {
            // Failed
            els.btn.classList.remove('btn-disabled');
            els.btn.textContent = "PLACE BET";
        }
    }

    async function doCashout() {
        if(!state.myBet || !state.myBet.active) return;
        
        // Optimistic disable
        els.btn.classList.add('btn-disabled');
        
        const res = await api('/api/cashout', { multiplier: state.currentMultiplier });
        
        if(res && res.status === 'cashed_out') {
            showToast(`You won ${res.payout.toFixed(2)}!`);
            updateBalance(res.balance);
            state.myBet = null; // Clear bet
        }
    }

    // ============================================
    // ANIMATION LOOP
    // ============================================
    function loop() {
        requestAnimationFrame(loop);
        graph.draw(state.gameState);
    }

    // Start
    init();

</script>
</body>
</html>